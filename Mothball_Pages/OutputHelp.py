import sys, os
# import tkinter as tk

folder_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '../'))
sys.path.append(folder_path)

# from ballgui import HelpPage
from Mothball_Pages.HelpPage import Page


class SettersAndOutputs(Page):
    def __init__(self, master = None, pack=True):
        super().__init__(master, pack)
        
        self.heading("Setter functions")
        self.insert_text("Many times, we want to extract useful information, but we must first be able to manipulate the simulation numbers before we can get an accurate, or even cleanly formatted result. That is what setter functions are for! Like the name says, they set values for certain things. If you read the Movement page, you already know 4 setters which were ")
        self.inline_code("face, turn, anglequeue, turnqueue")
        self.insert_text(". There are many more setters, and for many, they permanently change an attribute for the rest of the simulation.\n\n")

        self.inline_code("x"); self.insert_text(" - set the player's x position\n")
        self.inline_code("z"); self.insert_text(" - set the player's z position\n")
        self.inline_code("vx"); self.insert_text(" - set the player's x velocity\n")
        self.inline_code("vz"); self.insert_text(" - set the player's z velocity\n")
        self.inline_code("inertia"); self.insert_text(" - set the simulation's inertia threshold (0.005 in Minecraft 1.8, 0.003 in later versions)\n")
        self.inline_code("sprintairdelay"); self.insert_text(" or "); self.inline_code("sdel"); self.insert_text(" - toggles air sprint delay\n")
        self.inline_code("version"); self.insert_text(" or "); self.inline_code("ver"); self.insert_text(" or "); self.inline_code("v"); self.insert_text(" - set the simulation's version, accounting for differences in physics\n")
        self.inline_code("slip"); self.insert_text(" - set the default ground slipperiness (default 0.6)\n")
        self.inline_code("precision"); self.insert_text(" or "); self.inline_code("pre"); self.insert_text(" - sets how many decimals should outputs be rounded to\n")
        self.inline_code("var"); self.insert_text(" - assign a value to a variable\n")
        self.inline_code("increment"); self.insert_text(" or "); self.inline_code("inc"); self.insert_text(" - a variable that increments each time it is used to print outputs\n")
        self.inline_code("function"); self.insert_text(" or "); self.inline_code("func"); self.insert_text(" - define a new function\n")
        self.insert_text("Lastly, the pipeline ")
        self.inline_code("|")
        self.insert_text(" is an alias for ")
        self.inline_code("x(0) z(0)")
        self.insert_text(", or in words, resetting the player's position to (0,0).\n\n")


        self.heading("Output Functions")
        self.insert_text("In order to be able to extract useful information from Mothball, output functions are used. These functions output (duh) information at a specific tick.\n\n")

        self.inline_code("outz"); self.insert_text(" - outputs the player's z position\n")
        self.inline_code("outx"); self.insert_text(" - outputs the player's x position\n")
        self.inline_code("outvz"); self.insert_text(" - outputs the player's z velocity\n")
        self.inline_code("outvx"); self.insert_text(" - outputs the player's x velocity\n")
        self.inline_code("zb"); self.insert_text(" - outputs the player's z position in terms of blocks\n")
        self.inline_code("xb"); self.insert_text(" - outputs the player's x position in terms of blocks\n")
        self.inline_code("zmm"); self.insert_text(" - outputs the player's z position in terms of momentum\n")
        self.inline_code("xmm"); self.insert_text(" - outputs the player's x position in terms of momentum\n")
        self.inline_code("vec"); self.insert_text(" - outputs the player's total speed and angle of velocity\n")
        self.inline_code("effects"); self.insert_text(" - outputs the base speed modifier for potion effects speed and slow\n")
        self.inline_code("outangle"); self.insert_text(" or "); self.inline_code("outa"); self.insert_text(" - outputs the player's current facing\n")
        self.inline_code("outturn"); self.insert_text(" or "); self.inline_code("outt"); self.insert_text(" - outputs the player's last turn\n")
        self.inline_code("print"); self.insert_text(" - I think you know what this does\n")

        self.insert_text("\nThese functions can be used anytime for as many times as you need.\n\n")

        self.heading2("Function Arguments")
        self.insert_text("With the exception of ")
        self.inline_code("vec")
        self.insert_text(" and ")
        self.inline_code("effects")
        self.insert_text(", all other output functions share the same function two parameters, which take an ")
        self.inline_code("offset")
        self.insert_text(" and ")
        self.inline_code("label")
        self.insert_text(" in that order. The first parameter ")
        self.inline_code("offset")
        self.insert_text(" is a number, which if nonzero, will change the outputted number to be expressed as an expression containing that number. Take a look at the example.\n\n")
        self.code_snippet_with_output("s(5)\noutz\noutz(1)\noutz(-0.15)")
        self.insert_text("\nThe second parameter ")
        self.inline_code("label")
        self.insert_text(" will change the label in the output.\n")
        self.code_snippet_with_output("s(5)\noutz(1, hello world)")
        self.insert_text("\nIf you want to just change the label, then the following will work.\n")
        self.code_snippet("outz(0, new label)\noutz(0, label=new label)\noutz(label=new label)")
        self.insert_text("\n")

        self.heading2("Outx and Outz")
        self.insert_text("These functions output the player's x/z position change, exactly just like looking at coordinates in the in-game f3 menu. These functions are particularly useful for momentums or jumps with a single backwall or frontwall. For example, let's consider the following strat for 1.25bm cobblewall backwalled tier 1 4 block.\n")
        self.code_snippet_with_output("sa45(11) s45 outz(1.25)")
        self.insert_text("\nWe see that it uses almost all the momentum, leaving only 0.0011454 left, so this strategy is very good for this momentum. In fact it is also the most optional!\n\nTo double check this simulation, you can go in game and build the jump yourself. Suppose that leaning against the cobblewall gave a z coordinate of 4.05 (use f3 to check this). Then going in the positive direction, the edge should be at 5.3. From here, you can check that what we simulated matches in game.\n\n")

        self.heading2("Xb and Zb")
        self.insert_text("These functions output the player's x/z position in terms of blocks, or the distance of a jump that the player would be able to clear. To land a jump means to jump off the front of the momentum and land on the back of the landing block. Take a simple 4 block jump as an example, where it's a simple jump from one block to another, with no walls in the way. ")
        self.inline_code("xb")
        self.insert_text(" and ")
        self.inline_code("zb")
        self.insert_text(" are designed for these kind of jumps, such as a simple 4 block, 3x3 block, slab to fence 4.375 blocks, and so on. As the player is 0.6 bloks long, thes means the distance travelled (")
        self.inline_code("outx outz")
        self.insert_text(") is 0.6 shorter than the jump cleared.\n\nHow many blocks can you clear if you just jump forward from the edge of a block?\n")
        self.code_snippet_with_output("sj(12) zb")
        self.insert_text("\nSo the player can clear a flat 3.1875 (3 blocks + 3 pixels) block jump.\n\nFor the math nerds, the formula for ")
        self.inline_code("zb")
        self.insert_text(" is ")
        self.inline_code("zb = outz + 0.6")
        self.insert_text(" if ")
        self.inline_code("outz >= 0")
        self.insert_text(", otherwise ")
        self.inline_code("zb = outz - 0.6")
        self.insert_text(".\n\nA consequence of this is that it can also be used to simulate momentums that are frontwalled and backwalled at the same time, only this time, we want to check if the player doesn't make the distance to clear the jump. In the above example, we can see that just jumping forward fits a 3.25 frontwalled and backwalled momentum.\n\n")

        self.heading2("Xmm and Zmm")
        self.insert_text("These functions output the player's x/z position in terms of momentum. This is similar to ")
        self.inline_code("zb")
        self.insert_text(" and ")
        self.inline_code("xb")
        self.insert_text(" but in reverse. As such, this function is useful when there are no front or back walls on the momentum. These functions are great for the standard one block of momentum. Let's check how much momentum c4.5 uses.\n")
        self.code_snippet_with_output("wj(4) sa(8) s zmm(1)")
        self.insert_text("We use almost all of the momentum, leaving only 0.00615 unused.\n\nFor the math nerds, the formula for")
        self.inline_code("zmm")
        self.insert_text(" is ")
        self.inline_code("zmm = outz - 0.6")
        self.insert_text(" if ")
        self.inline_code("zmm >= 0")
        self.insert_text(", otherwise ")
        self.inline_code("zmm = outz + 0.6")
        self.insert_text(".\n\nA consequence of this is that it can also be used to simulate simple linear neos where the jump block is frontwalled and the land block is backwalled, only this time, we want to be able to clear the distance. So what z neo could headhitter (hh) pass?\n")
        self.code_snippet_with_output("s sj(11) zmm")
        self.insert_text("\nSo the player can make a 2.1875 block z neo, or a double neo with a trapdoor. The reason why its ")
        self.inline_code("sj(11)")
        self.insert_text(" and not ")
        self.inline_code("sj(12)")
        self.insert_text(" is because in a z neo, the tick before landing is what determines whether you made enough distance to land the neo. The explanation of that has to do with the order of collision calculation being X before Z. Find more information about this at ")
        self.link("https://www.mcpk.wiki/wiki/Collisions")
        self.insert_text(".\n\n")

        self.heading2("Outvx and Outvz")
        self.insert_text("This is self-explanatory, it just outputs the player's x/z velocity. Here's a random example.\n")
        self.code_snippet_with_output("sj(12) s outvz")
        self.insert_text("\n")

        self.heading2("Vec")
        self.insert_text("This function outputs the player's total speed and angle of velocity. Total speed means it takes in the x and z speed and calculate the  norm, or in math equations, sqrt(vz^2 + vx^2). Here's an example.\n")
        self.code_snippet_with_output("sj.wa(12) s.wa vec")
        self.insert_text("\n")
    
        self.heading2("Outangle")
        self.insert_text("This function outputs the player's current facing on that tick. This is particularly useful if for example you are using a long ")
        self.inline_code("tq")
        self.insert_text(" sequence. Math is hard, so Mothball does it for you!\n")
        self.code_snippet_with_output("f(3) tq(5,-3,8,6,-2) w(6) outa")
        self.insert_text("\n")

        self.heading2("Effects")
        self.insert_text("This function will display the base speed modification given a speed and slowness amplifier. The formula is MAX((1 + 0.2 * speed)(1 - 0.15 * slow), 0). For example,\n")
        self.code_snippet_with_output("effects(speed=4, slow=3)")
        self.insert_text("\nIf the result would be negative, then the base speed is set to 0. This means that you cannot move on ground at all. You can still move in air, as potions don't affect your air movement.\n")
        self.insert_text("\n")

        self.heading2("Print")
        self.insert_text("It's in the name. Use ")
        self.inline_code("print")
        self.insert_text(" to print any text you want. This could be useful for taking notes or tracking parts of a simulation and organizing the outputs. Here's an example of how ")
        self.inline_code("print")
        self.insert_text(" might be used in a real Mothball application.\n")
        self.code_snippet_with_output("""f(7.05) print(on momentum) w.d(2) s.wd(4) xmm(-0.25) x(0) 
sj outz(0.625) z(0) print(on neo) sa.wa outx(-0.375, label=x blockage 1)

f(-42.95) sa.wa(6) outx(-0.375, label=x blockage 2) zmm(1, z neo) print(after neo)
sa.wa(4) outx(0.0625, offset)""")
        self.insert_text("\nYou can also print expressions which will be evaluated. To do this, put your expression inside curly brackets ")
        self.inline_code("{}")
        self.insert_text(". For example, all Mothball simulations have ")
        self.inline_code("px")
        self.insert_text(" as a variable which equals 0.0625, or 1/16. This means...\n\n")
        self.code_snippet_with_output("print(A pixel is {px} blocks\, and 8 pixels is {8*px} blocks)")
        self.insert_text("\nNotice the backslash ")
        self.inline_code("\\")
        self.insert_text(" placed before the comma. A backslash acts just like any programming language would, which escapes the next character. In Mothball, a comma is used to separate arguments, and since strings have no delimiters, backslashes are used to indicate that the comma is part of the string. The backslash can also escape other characters, mainly ")
        self.inline_code("{}(),=#")
        self.insert_text(".")

        
        self.finalize()

if __name__ == "__main__":
    a = SettersAndOutputs()
    a.mainloop()
